校园招聘时期：

1. 写出中序遍历二叉树的非递归算法

死锁是什么？必要条件是什么？如何避免？
	死锁是两个或者多个进程互相等待对方占有的资源，彼此都无法得到而陷入死循环阻塞状态。
	四个必要条件是：互斥访问资源、资源不可剥夺、占有并请求、循环等待。
	死锁的避免就是从破坏死锁的必要条件出发：进程资源可剥夺，全部分配资源，资源按序分配。（互斥条件是无法破坏的）



什么是多态？
	多态即是“一个接口，多个方法”，程序运行时才决定调用哪个函数。多态允许基类赋值为它的子类对象，赋值后根据子类对象的特性
	以不同的方式运行，简单的说就是可以将派生类指针赋值给基类指针。C++的多态是通过虚函数来实现的，多态实现了接口复用。
什么是虚函数？
	虚函数是使用virtual关键字定义的成员函数，虚函数允许子类重新定义，其作用是为了实现多态。
什么是观察者模式？
	一个目标对象管理所有依赖于它的观察者，当目标的状态发生改变时，主动发出通知，一般是通过调用观察者提供的方法实现。
	常被用于实时事件处理系统，例如GUI系统中，业务数据就是目标，用户界面是观察者，当数据发生改变，界面实时变化。
什么是单例模式？
	其核心是一个特殊类，单例类。该类只允许有一个实例且可以方便的被外界访问，从而满足系统的实际需求。
进程和线程的区别？
	1）进程是程序的一次执行，线程是进程中的一段控制序列；
	2）进程是独立的，有独立的进程空间，线程位于进程空间内部，多个线程共享同一内存空间；
	3）同一进程中的两段代码不能同时执行，除非引入线程；
	4）进程是资源分配和拥有的单位，线程是处理机调度的单位；
	5）因为有独立的内存空间，所以切换时要保存调用栈信息，各寄存器状态等内容，进程切换耗费资源，开销较大，效率低。多线程共享
	   内存空间，所以切换效率相对较高。
	6）多进程更加健壮，多线程中一个线程崩溃会导致整个进程终止
如何判断程序是由C编译程序还是C++编译程序？
	使用 #ifdef  _cplusplus    .....     #endif 包围代码。因为若是C++编译程序，系统会自定义宏 _cplusplus。
谈谈const关键字的理解？
	1）定义const常量，定义时即初始化；2）可以修饰函数参数，返回值，函数体，被修饰对象受到强制保护，防止意外变动，提高程序健壮性。
析构函数为什么要是声明为虚函数？
	由于继承和多态的存在，当基类操作派生类，在析构时防止只析构基类而不析构派生类的情况发生。
静态链接库和动态链接库的区别？
	静态链接库一般为libxxx.a，整个函数库被编译到可执行程序中，产生的文件较大，优点是不需要外部的函数库支持，但是如果静态函数库
	改变，需要重新编译程序；动态链接库一般为libxxx.so，函数库不编译到目标代码，程序调用相关函数时才去加载，因此可执行文件较小，
	缺点是动态申请并调用，程序运行环境依赖相应的函数库，动态库的改变并不影响执行程序，升级较为方便。
vector是怎么实现的？
	vector是用动态数组实现的，当插入元素时如果capacity被占满就重新分配内存，一般是原大小的两倍。然后把原数组拷贝过去。
	所以，一般情况下其访问速度同数组，只有在重新分配空间时性能才会下降。其内部使用allocator类进行内存管理。
	STL是标准模板库，具有工业强度，高效的C++程序库，安全高效，方便，跨平台。由模板、容器、迭代器组成。
什么是二叉排序树？
	二叉排序树要么是空树，要么具有以下三性质：1）左子树所有结点的值小于根节点；2）右子树所有结点的值大于根节点；3）
	左右子树都是二叉排序树。
	二叉排序树的插入不进行结点的旋转，删除叶子节点也不需要旋转，删除非叶子节点需要做几步简单的调整操作。
红黑树和平衡二叉树有什么优缺点？
	红黑树是一中特殊的二叉查找树，它的5个性质使它具有平衡特性，二叉树的平衡性能越好，效率也就越高。
	红黑树的平衡性能低于AVL（平衡二叉树），但仍然能够使得最坏情况下，查找、插入、删除操作的复杂度为O(logn)。
	红黑树是一种不严格的平衡二叉树。查找效率红黑树低于AVL（因为平衡性能），插入、删除结点时需要的旋转
	操作次数红黑树（都在三次之内）小于AVL。红黑树和AVL时间复杂度相同，但红黑树统计性能更高。
你知道布隆过滤器吗？
	就是长度为m的位数组+k个哈希函数，m和k与输入规模n和错误率E有对应公式。Bloom Filter和单哈希bitmap的区别是使用了k
	个哈希函数，每个输入数据对应k个bit位，降低了冲突的概率。布隆过滤器用于大规模数据处理，有100%的召回率，用于检测
	一个元素是否在集合里，若检查结果为否，则一定不在该集合，若检查结果为是，元素不一定存在于该集合。优点是查找和插入
	数据的时间为常数，缺点是插入元素越多，出错的概率越大，而且不能删除元素。使用改进型的CBF，将每一个bit替换成一个计数器
	就能实现删除元素的目的。
	m的计算公式m= - (n*lnP)/(ln2)^2，P为错误率，如果设置为小于1%的数1/128的话，基本上m = 10*n，k= -lnP/ln2，P=1/128，k=7。
线程同步和互斥有什么区别？分别在什么情况下使用它们？
	线程的互斥是一种特殊的同步。
	当要求访问资源需要先后顺序的时候，或者一个线程的执行依赖于另一个线程完成某种操作的时候使用同步。
	当需要独占式访问资源时需要互斥。
	一个生产者和多个消费者的问题，生产者和消费者是线程同步，多个消费者之间是线程的互斥。
你说自己精通多线程编程，介绍一下吧
	多线程一般用boost，linux调用是pthread_create(线程标识符，线程属性结构体，函数指针，函数参数)，pthread_exit()，pthread_join()
	等待其他线程结束。
	多线程同步的方式：信号量，互斥锁，条件变量。还有读写锁
	信号量：sem_init(), sem_wait(), sem_post(), sem_destroy()
	互斥锁：pthread_mutex_init(), pthread_mutex_lock(), pthread_mutex_unlock(), pthread_mutex_destroy()
	条件变量：pthread_cond_init(), pthread_cond_wait(), pthread_cond_signal(), pthread_cond_broadcast(), pthread_cond_destroy()


﻿select和epoll相比的优缺点？
	socket编程中I/O多路复用有select, poll, epoll。
	select的缺点有 1）连接数受到限制，默认1024；2）随着连接数的增加，性能会下降，因为每都需要线性扫描文件描述符集合fd_set；
	3）每次需要将文件描述符集合在用户空间和内核之间拷贝，开销较大；4）select只支持水平触发。select的优点是简单。
	poll的实现和select相似，只是文件描述符集合采用pollfd而不是fd_set。
	epoll的优点：1）几乎没有连接数的限制，只受机器硬件资源限制；2）连接数增加不会导致性能下降，因为每次只有就绪的IO事件才会
	主动调用call_back函数，将事件从红黑树移动到就绪队列中，然后系统调用返回通知应用程序，返回的只有IO已就绪事件；3）使用mmap
	技术加速内核与用户空间的消息传递；4）epoll支持水平触发和边缘触发。
	epoll是用红黑树（存放应用程序注册的事件）+ 双向链表（存放已就绪事件）实现的。适用于连接数较多，但是活动连接数较少的情况。
水平触发和边缘触发有什么区别？
	水平触发是指当IO事件就绪时，epoll_wait调用返回会通知应用程序，如果应用程序没有处理或者fd上还有未处理的数据，那么epoll_wait
	调用返回，应用程序会一直得到通知，这种模式可以保证数据的完整传输。边缘触发则只会在第一次对应用程序进行通知，属于高速模式，
	由于避免了同一个事件的多次触发，减少了内核资源的消耗，更高效（只支持非阻塞IO）。
I/O多路复用一般的应用场景：
	1，一个客户端同时处理多个文件描述符的输入输出操作时
	2，一个程序同时处理多个套接字
	3，TCP服务器程序同时处理监听套接字和客户连接套接字
	4，服务器程序同时处理TCP和UDP协议
	5，服务器同时使用多种服务而每个服务使用的协议都有可能不同（如inetd）。
多态在编译器里怎么实现的？
	C++编译器发现类中有虚函数，就为该类型建立一个虚函数表（存储虚成员函数指针的数据结构），类的每个实例中包含一个vptr指针。
	对象创建时，编译器根据对象的类型初始化vptr指针，从而让vptr正确的指向所属类的虚函数表。程序运行到动态绑定时，通过基类指针
	（或引用）指向的对象类型包含的vptr指针，找到相应的虚函数表vtable，然后调用相应方法，实现多态。

代码段、数据段、堆栈段，进程的内存空间结构
	代码段就是存放程序代码文本，是只读的；
	数据段包含非零数据区，BSS，和堆（heap）。非零数据区存放初始化后的全局变量和静态变量，BSS存放未初始化的全局数据和静态数据，
		还有就是堆，这个区域供动态分配内存使用
	堆栈段（注意，堆栈段是stack，堆是heap），存放局部变量和函数参数。

异步为何有高性能？如果是因为起了多个线程，那同步我也可以起多个线程啊？
	同步IO使用多进程/多线程模型虽然能够解决程序并发问题，但是系统上线程数不是无限制增加的，而且由于系统切换线程的开销也很大，
	所以，一旦线程数量过多，CPU的时间都花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。

深刻理解TCP/IP，深刻理解异步高并发网络应用开发；（优酷土豆Linux C++服务端开发工程师）


Mysql三种引擎的区别？OLAP,OLTP锁机制，存储限制，是否支持事务，全文索引	
	InnoDB支持事务，锁的粒度在row，存储容量最大64TB，支持哈希索引，不支持全文索引，支持外键；MyISAM不支持事务，锁的粒度在table，
	存储容量无限制，不支持哈希索引，支持全文索引，不支持外键。

多线程模型都有哪些？
	按需创建，线程池，Leader-Follower模式
说说IO的同步非同步，阻塞非阻塞
	同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待（阻塞式）或者轮询的去查看IO操作是否就绪（IO
	复用），IO就绪后，内核通知应用程序，然后由应用程序完成实际的IO操作。而异步指的是用户进程触发IO操作后开始做自己的事情，
	当IO事件就绪并且由内核完成IO操作（从内核空间拷贝到用户空间，以recvfrom为例）后，内核通知应用程序IO完成。
	阻塞和非阻塞是针对进程在访问数据的时候采取的不同方式，阻塞方式下读写一个文件描述符，如果IO事件未就绪，无数据可读或者无法写
	数据就会一直阻塞等待，直到IO操作完成。非阻塞就是读写fd立即返回，返回成功就是操作完成，失败就会设置相应的errno状态码。
	理论上来说，阻塞IO，IO复用（包括epoll）和信号驱动IO都属于同步IO模型。

Redis数据库
	redis是基于内存的高性能key-value数据库，整个数据库加载到内存中，定期以异步的方式flush到硬盘，具有快速和持久化的特点。因为是
	纯内存操作，性能非常好，可以到达每秒10万次的读写操作，是已知性能最好的key-value数据库。redis最大的特点是支持多种数据结构，
	单个value的最大限制是1GB。redis可以对存入的key-value设置过期时间。redis最大的缺点是数据库容量受物理内存的限制，适合小数据量
	的高性能操作和运算。redis是单进程和单线程，将并发访问变为串行访问。在分布式方面，redis支持主从模式。原则是master会将数据
	同步到slave，而slave不会将数据同步到master，这是典型的分布式读写分离模型。我们可以利用master来增删数据，slave提供检索，这样
	可以有效减少单个机器的并发访问数量。通过增加slave DB的数量，读的性能可以线性增加。读写分离架构的缺陷在于，不管是master还是
	slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力受限于单个节点的存储能力，而且对于写频繁的
	类型系统，读写分离架构并不合适。


在浏览器中输入网址后都发生了什么（一次HTTP事务的流程）？
	1，域名解析，2，TCP三次握手连接，3，填充http请求报文（包含请求方法等内容），4，服务端填充响应报文（包括响应状态码，
	报文主体等内容），5，客户端解析html并请求其中的资源，6，页面渲染呈现给用户

﻿堆和栈的区别？
	1）堆由程序手动申请，栈由系统自动分配
	2）堆在内存空间中由低地址向高地址增长，是不连续的，栈是由高地址向低地址增长，内存是连续的
	3）堆的空间一般较大，栈的分配空间较小（windows是2M)
	4）堆的分配因为是不连续的，容易产生碎片，栈的分配运算包含在处理器的指令集中，分配效率非常高
	5）堆中存放的内容有程序手动指定，栈中存放局部变量，函数参数，返回值，返回地址

Reactor模式
	是一种事件驱动机制，应用程序需要提供相应的接口并注册到reactor上，如果相应的事件发生，reactor将主动调用应用程序注册的接口进行处理。

设计模式
	单例模式，桥接模式，观察者模式，Reactor模式，装饰器模式。

python的标记-清除机制
	为了解决循环引用导致的内存泄漏。首先初始化所有的对象为白色，并确定根节点对象（从寄存器和执行栈）标记为黑色，表示对象有效，把根节点
	引用的对象标记为灰色，然后检查完灰色节点的引用对象后，把灰色标记为黑色，重复这个过程直到灰色节点不存在。剩下的白色节点就是需要清除
	的对象。
Python的分代回收垃圾回收机制
	
libevent编程步骤
	使用event_base_new()新建一个event_base，然后socket()出一个监听套接字，fcntl()设置套接字为非阻塞，bind()，listen()，使用event_new()
	新建一个事件用于接收连接请求event_new(base, listener, EV_READ|EV_PERSIST, on_accecpt, base)，event_add()添加事件到libevent中，最后
	event_base_dispatch()启动libevent中的事件循环。
	on_accept()处理函数中，line_fd=accept()，fcntl()设置连接套接字非阻塞，未使用bufferevent的话就自定义管理缓冲区的结构体state，为这个
	连接套接字分配缓冲区，并把连接套接字的读事件添加到libevent循环中，在业务逻辑里适当时机添加连接套接字的写事件。
	有了bufferevent后，就不必自己手动维持一个buffer，libevent提供了一个通用的机制。bufferevent封装了两个event，一个读事件，一个写事件，
	和对应的buffer，以及对应的处理回调函数。使用方法跟自己管理buffer的区别是on_accept()中，将连接套接字设置为非阻塞后使用
	bufferevent_socket_new()创建一个bufferevent，然后设置读写对应的回调函数，最后使用bufferevent_enable()启动读写事件，其实就是调用
	event_add()添加事件到libevent事件循环中。bufferevent使用watermark水位线来定义回调函数的调用时机，默认情况当读缓冲区有数据就调用读
	回调函数，当写缓冲区数据发送完成调用写回调函数。

valgrind是一套用于内存调试，内存泄漏检测，内存性能分析的工具，最常用的是Memcheck，它能发现的问题包括：未初始化内存，内存读写越界，内存覆盖，
	程序动态内存管理错误（new和delete不一致，释放后仍然读写等等），内存泄漏。

常看的技术博客有哪些？
	CSDN，博客园，找代码会到github，搜索一些知识点经常去知乎，寻找开发遇到的难题会用google和stackoverflow。

关系数据库和非关系数据库的区别？
	关系数据库基于表，非关系数据库基于key-value,文档等等。
	关系数据库中的数据结构必须事先定义，非关系型数据库可以动态扩展；
	关系数据库擅长处理复杂的查询，非关系数据库不擅长；
	关系数据库适合基于大量事务的场景，因为有ACID属性，非关系数据库对事务的处理能力有限。
cookie和session
	cookie保存在客户端，session保存在服务端。cookie用来保存用户信息，session用来跟踪用户会话，保存用户登录状态。
	大致流程是：用户登录时，用户名和密码验证通过，服务端生成session，并设置cookie返回给客户端，里面包含随机并唯一的长字符串也就是session
	ID，以后用户的每个请求都把session ID带上来，服务端就知道是哪个用户发出的请求了。同时，cookie可以在客户端保存用户的用户名和密码，
	下次不用手动再次输入，直接发送登录请求。
使用Redis做缓存
	首先，不是所有的数据都需要缓存，基本什么数据用缓存取决于三点：1，热点数据，访问比较频繁；2，相对比较稳定，不会经常变动；3，数据重要
	性不是很高，丢失了也无所谓。具体可用于缓存的数据有session回话，博客文章，帖子评论等。
	缓存读取流程：先到Redis中读数据，如果不存在再读数据库，从数据库中读取到的数据返回的同时放入Redis
	缓存更新流程：update/delete操作，首先更新数据库，然后让Redis中的数据过期或失效。
	
MySQL优化
	1）配置优化，例如最大连接数，缓存大小等参数；
	2）适当的添加索引；
	3）SQL语句的优化，配合索引；
	4）数据库分库和分表；
	5）读写分离
	
GDB原理
	gdb使用了ptrace系统调用，在gdb和被调试的程序之间建立了追踪关系。除了SIGKILL外，所有发送给被调试程序的信号都会被gdb捕获，内核在
	执行被跟踪程序发出的系统调用时，会检查程序是否在“被跟踪状态”，如果是的话，就把执行权交给跟踪进程，使得跟踪进程可以调用多个ptrace
	请求来检查并控制被调试程序的内存地址和寄存器。
	GDB有两种调试模式：1，使用gdb启动程序；2，attach到已经运行的程序。
	第1种是利用fork+execve，gdb调试时先fork出一个子进程，然后在子进程中调用ptrace建立与父进程（gdb）的追踪关系。
	第2种是调用ptrace使自己变为被调试进程的父进程。

﻿高并发程序如何优化？每天千万订单如何处理？
	Nginx做负载均衡，服务器集群共享session等缓存；
	使用keepalived或者LVS，supervisor保证高可用性；
	使用Redis做缓存，常用的且不会经常发生改变的数据放在缓存中；
	MySQL做主从备份，读写分离，增强高并发下的可用性；
	MySQL的分库和分表，已经建立索引等语句层面的优化；
	使用消息队列，降低系统间的耦合度，同时有些对时间不敏感的业务可以延迟处理；
	动态和静态资源分离，比如图片作为最消耗资源的对象，把图片和页面进行分离；

数据库事务
	数据库事务是一个或者多个SQL语句构成的，这些语句要么都执行，要么都不执行。
	事务的四个特性：ACID
	原子性，事务中的语句全部执行成功了，事务才算是成功执行，如果有一个执行失败，所有已经执行的SQL需要rollback；
	一致性，一个事务把数据库从一个状态转变到另一个状态，事务执行前后数据库的完整性约束不会被破坏；
	隔离性，是为了并发控制。要求每个事务处理的对象和其他事务操作的对象相互分离，也就是说该事务提交前对其他事务是不可见的，通常
	             使用锁来实现；
	持久性，事务一旦提交了，其结果是永久性的，如果发生故障也可以进行数据恢复。
